//===- ToyCompiler.cpp - libclang-based toy compiler example -------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This example shows how to drive libclang from C++ in order to build a tiny
// stack-machine compiler.  The goal is not to be feature complete, but to give
// a realistic starting point for experimenting with the libclang C interface.
//
// The program consumes a C++ source file, parses it into an AST via libclang
// and then lowers a restricted subset of functions into a toy bytecode format.
// Supported inputs are intentionally small: functions must return an integer,
// the body must consist of a single return statement and the returned
// expression may combine integer literals with the operators '+', '-' and '*'.
// For every function that satisfies those requirements the compiler prints the
// generated bytecode.
//
//===----------------------------------------------------------------------===//

#include "clang-c/Index.h"

#include <cstdlib>
#include <iostream>
#include <optional>
#include <sstream>
#include <string>
#include <utility>
#include <vector>

namespace {

std::string toStdString(CXString Str) {
  std::string Result;
  if (const char *Chars = clang_getCString(Str))
    Result.assign(Chars);
  clang_disposeString(Str);
  return Result;
}

struct ToyInstruction {
  enum class Opcode { PushInt, Add, Sub, Mul, Return };

  Opcode Op;
  int Value = 0;
};

struct ToyFunction {
  std::string Name;
  std::vector<ToyInstruction> Body;
};

class ToyCompiler {
public:
  explicit ToyCompiler(CXTranslationUnit TU) : TU(TU) {}

  void compile();
  void dumpProgram(std::ostream &OS) const;

private:
  CXTranslationUnit TU;
  std::vector<ToyFunction> Functions;

  bool compileFunction(CXCursor Cursor);
  bool compileReturnStmt(CXCursor Cursor, ToyFunction &Fn);
  bool compileExpr(CXCursor Cursor, ToyFunction &Fn);
  bool compileBinaryOperator(CXCursor Cursor, ToyFunction &Fn);
  bool compileIntegerLiteral(CXCursor Cursor, ToyFunction &Fn);
  std::optional<ToyInstruction::Opcode> decodeOperator(CXCursor Cursor) const;
  std::string describeLocation(CXCursor Cursor) const;

  static CXChildVisitResult translationUnitVisitor(CXCursor Cursor,
                                                   CXCursor Parent,
                                                   CXClientData Data);
};

void ToyCompiler::compile() {
  CXCursor TranslationUnitCursor = clang_getTranslationUnitCursor(TU);
  clang_visitChildren(TranslationUnitCursor, &ToyCompiler::translationUnitVisitor,
                      this);
}

CXChildVisitResult ToyCompiler::translationUnitVisitor(CXCursor Cursor,
                                                       CXCursor /*Parent*/,
                                                       CXClientData Data) {
  auto *Self = static_cast<ToyCompiler *>(Data);
  CXCursorKind Kind = clang_getCursorKind(Cursor);
  if ((Kind == CXCursor_FunctionDecl || Kind == CXCursor_CXXMethod) &&
      clang_isCursorDefinition(Cursor)) {
    if (!Self->compileFunction(Cursor))
      std::cerr << "Skipping unsupported function at "
                << Self->describeLocation(Cursor) << "\n";
    return CXChildVisit_Continue;
  }

  return CXChildVisit_Recurse;
}

bool ToyCompiler::compileFunction(CXCursor Cursor) {
  ToyFunction Fn;
  Fn.Name = toStdString(clang_getCursorSpelling(Cursor));

  struct FunctionContext {
    ToyCompiler *Self;
    ToyFunction *Fn;
    bool Success = true;
    bool SawReturn = false;
  } Ctx{this, &Fn, true, false};

  clang_visitChildren(Cursor,
                      [](CXCursor Child, CXCursor, CXClientData Data) {
                        auto &Ctx = *static_cast<FunctionContext *>(Data);
                        if (clang_getCursorKind(Child) == CXCursor_CompoundStmt) {
                          clang_visitChildren(
                              Child,
                              [](CXCursor Stmt, CXCursor, CXClientData Data) {
                                auto &InnerCtx =
                                    *static_cast<FunctionContext *>(Data);
                                if (clang_getCursorKind(Stmt) ==
                                    CXCursor_ReturnStmt) {
                                  if (InnerCtx.SawReturn) {
                                    InnerCtx.Success = false;
                                    return CXChildVisit_Break;
                                  }
                                  if (!InnerCtx.Self->compileReturnStmt(
                                          Stmt, *InnerCtx.Fn)) {
                                    InnerCtx.Success = false;
                                    return CXChildVisit_Break;
                                  }
                                  InnerCtx.SawReturn = true;
                                  return CXChildVisit_Continue;
                                }
                                if (clang_isStatement(
                                        clang_getCursorKind(Stmt))) {
                                  InnerCtx.Success = false;
                                  return CXChildVisit_Break;
                                }
                                return CXChildVisit_Continue;
                              },
                              Data);
                          return CXChildVisit_Break;
                        }
                        return CXChildVisit_Continue;
                      },
                      &Ctx);

  if (!Ctx.Success || Fn.Body.empty() || !Ctx.SawReturn)
    return false;

  Functions.push_back(std::move(Fn));
  return true;
}

bool ToyCompiler::compileReturnStmt(CXCursor Cursor, ToyFunction &Fn) {
  struct ReturnContext {
    ToyCompiler *Self;
    ToyFunction *Fn;
    bool Success = false;
  } Ctx{this, &Fn, false};

  clang_visitChildren(Cursor,
                      [](CXCursor Child, CXCursor, CXClientData Data) {
                        auto &Ctx = *static_cast<ReturnContext *>(Data);
                        if (Ctx.Self->compileExpr(Child, *Ctx.Fn)) {
                          Ctx.Success = true;
                          return CXChildVisit_Break;
                        }
                        return CXChildVisit_Break;
                      },
                      &Ctx);

  if (!Ctx.Success)
    return false;

  Fn.Body.push_back({ToyInstruction::Opcode::Return, 0});
  return true;
}

bool ToyCompiler::compileExpr(CXCursor Cursor, ToyFunction &Fn) {
  switch (clang_getCursorKind(Cursor)) {
  case CXCursor_UnexposedExpr:
  case CXCursor_ParenExpr: {
    struct UnexposedContext {
      ToyCompiler *Self;
      ToyFunction *Fn;
      bool Success = false;
    } Ctx{this, &Fn, false};

    clang_visitChildren(Cursor,
                        [](CXCursor Child, CXCursor, CXClientData Data) {
                          auto &Ctx = *static_cast<UnexposedContext *>(Data);
                          if (!Ctx.Success)
                            Ctx.Success = Ctx.Self->compileExpr(Child, *Ctx.Fn);
                          return CXChildVisit_Break;
                        },
                        &Ctx);
    return Ctx.Success;
  }
  case CXCursor_IntegerLiteral:
    return compileIntegerLiteral(Cursor, Fn);
  case CXCursor_BinaryOperator:
    return compileBinaryOperator(Cursor, Fn);
  default:
    std::cerr << "Unsupported expression kind at " << describeLocation(Cursor)
              << "\n";
    return false;
  }
}

bool ToyCompiler::compileBinaryOperator(CXCursor Cursor, ToyFunction &Fn) {
  std::vector<CXCursor> Children;
  clang_visitChildren(Cursor,
                      [](CXCursor Child, CXCursor, CXClientData Data) {
                        auto *Storage = static_cast<std::vector<CXCursor> *>(Data);
                        Storage->push_back(Child);
                        return CXChildVisit_Continue;
                      },
                      &Children);

  if (Children.size() != 2) {
    std::cerr << "Binary operator does not have two operands at "
              << describeLocation(Cursor) << "\n";
    return false;
  }

  if (!compileExpr(Children[0], Fn) || !compileExpr(Children[1], Fn))
    return false;

  auto Op = decodeOperator(Cursor);
  if (!Op) {
    std::cerr << "Unsupported operator at " << describeLocation(Cursor)
              << "\n";
    return false;
  }

  Fn.Body.push_back({*Op, 0});
  return true;
}

bool ToyCompiler::compileIntegerLiteral(CXCursor Cursor, ToyFunction &Fn) {
  CXToken *Tokens = nullptr;
  unsigned NumTokens = 0;
  clang_tokenize(TU, clang_getCursorExtent(Cursor), &Tokens, &NumTokens);

  std::optional<int> Value;
  for (unsigned I = 0; I < NumTokens; ++I) {
    std::string Spelling = toStdString(clang_getTokenSpelling(TU, Tokens[I]));
    char *End = nullptr;
    long Parsed = std::strtol(Spelling.c_str(), &End, 10);
    if (End && *End == '\0') {
      Value = static_cast<int>(Parsed);
      break;
    }
  }

  clang_disposeTokens(TU, Tokens, NumTokens);

  if (!Value) {
    std::cerr << "Could not read integer literal at "
              << describeLocation(Cursor) << "\n";
    return false;
  }

  Fn.Body.push_back({ToyInstruction::Opcode::PushInt, *Value});
  return true;
}

std::optional<ToyInstruction::Opcode>
ToyCompiler::decodeOperator(CXCursor Cursor) const {
  CXToken *Tokens = nullptr;
  unsigned NumTokens = 0;
  clang_tokenize(TU, clang_getCursorExtent(Cursor), &Tokens, &NumTokens);

  std::optional<ToyInstruction::Opcode> Result;
  for (unsigned I = 0; I < NumTokens; ++I) {
    std::string Spelling = toStdString(clang_getTokenSpelling(TU, Tokens[I]));
    if (Spelling == "+") {
      Result = ToyInstruction::Opcode::Add;
      break;
    }
    if (Spelling == "-") {
      Result = ToyInstruction::Opcode::Sub;
      break;
    }
    if (Spelling == "*") {
      Result = ToyInstruction::Opcode::Mul;
      break;
    }
  }

  clang_disposeTokens(TU, Tokens, NumTokens);
  return Result;
}

std::string ToyCompiler::describeLocation(CXCursor Cursor) const {
  CXSourceLocation Location = clang_getCursorLocation(Cursor);
  CXFile File = nullptr;
  unsigned Line = 0;
  unsigned Column = 0;
  clang_getFileLocation(Location, &File, &Line, &Column, nullptr);

  std::ostringstream OS;
  if (File)
    OS << toStdString(clang_getFileName(File));
  else
    OS << "<unknown>";
  OS << ':' << Line << ':' << Column;
  return OS.str();
}

void ToyCompiler::dumpProgram(std::ostream &OS) const {
  if (Functions.empty()) {
    OS << "No functions were compiled.\n";
    return;
  }

  for (const ToyFunction &Fn : Functions) {
    OS << "fn " << Fn.Name << "()\n";
    for (const ToyInstruction &Inst : Fn.Body) {
      switch (Inst.Op) {
      case ToyInstruction::Opcode::PushInt:
        OS << "  push " << Inst.Value << "\n";
        break;
      case ToyInstruction::Opcode::Add:
        OS << "  add\n";
        break;
      case ToyInstruction::Opcode::Sub:
        OS << "  sub\n";
        break;
      case ToyInstruction::Opcode::Mul:
        OS << "  mul\n";
        break;
      case ToyInstruction::Opcode::Return:
        OS << "  ret\n";
        break;
      }
    }
    OS << "end\n\n";
  }
}

} // namespace

int main(int argc, char **argv) {
  if (argc < 2) {
    std::cerr << "Usage: LibClangToyCompiler <source-file> [clang-args...]\n";
    return 1;
  }

  CXIndex Index = clang_createIndex(/*excludeDeclsFromPCH=*/0, /*displayDiagnostics=*/0);

  const char **ClangArgs = nullptr;
  int NumArgs = argc - 2;
  if (NumArgs > 0)
    ClangArgs = const_cast<const char **>(&argv[2]);

  CXTranslationUnit TU = clang_parseTranslationUnit(
      Index, argv[1], ClangArgs, NumArgs,
      nullptr, 0, CXTranslationUnit_None);
  if (!TU) {
    std::cerr << "Failed to parse translation unit '" << argv[1] << "'.\n";
    clang_disposeIndex(Index);
    return 1;
  }

  unsigned NumDiagnostics = clang_getNumDiagnostics(TU);
  for (unsigned I = 0; I < NumDiagnostics; ++I) {
    CXDiagnostic Diagnostic = clang_getDiagnostic(TU, I);
    std::string Message = toStdString(clang_formatDiagnostic(
        Diagnostic, clang_defaultDiagnosticDisplayOptions()));
    std::cerr << Message << '\n';
    clang_disposeDiagnostic(Diagnostic);
  }

  ToyCompiler Compiler(TU);
  Compiler.compile();
  Compiler.dumpProgram(std::cout);

  clang_disposeTranslationUnit(TU);
  clang_disposeIndex(Index);
  return 0;
}
